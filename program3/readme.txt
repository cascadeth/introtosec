  _____          _   _       _   _     _
 |  __ \        | \ | |     | | | |   (_)
 | |  | | ___   |  \| | ___ | |_| |__  _ _ __   __ _
 | |  | |/ _ \  | . ` |/ _ \| __| '_ \| | '_ \ / _` |
 | |__| | (_) | | |\  | (_) | |_| | | | | | | | (_| |
 |_____/ \___/  |_| \_|\___/ \__|_| |_|_|_| |_|\__, |
                                                __/ |
                                               |___/

Instructions on Running:

        1. Provide a secret key in your own file.

           E.g.
           $ cat my_key.txt
           ThisIsAwesomeKey

        2. Run the script with the secret key file as the only argument:

           E.g.
           $ python do_nothing.py my_key.txt

Note on Phase Difference:

        For some reason, and it may just be where I live, token generation is
        not synced, and in fact, it's roughly 15 seconds off phase.  New codes
        generated by the G. Authenticator app, at its time=0, are not good for 15
        seconds at the running script.  Codes therefore, the script's codes are
        good 15 seconds past expiration on the G. Authenticator app.  The script's
        time is 15 seconds past the app's.  For example:

        Going off the Google Authenticator App's time interval starts:

            Mobile App @ 0  sec : 123456
            DN Script  @ 0  sec : 019283   <-- technically G. Auth's previous value (t < 0)

            Mobile App @ 15 sec : 123456
            DN Script  @ 15 sec : 123456   <-- script creates new token which matches \ -- Time frame to use token effectively before mobile app switches
                                                                                    /
            Mobile App @ 30 sec : 987654   <-- G. Auth creates new token                -- Can still use previously generated mobile token with the script
            DN Script  @ 30 sec : 123456   <-- script still maintains old

            Mobile App @ 45 sec : 987654
            DN Script  @ 45 sec : 987654   <-- script creates new token which matches \ -- Time frame to use token effectively before mobile app switches
                                                                                    /
            Mobile App @ 60 sec : 135791   <-- G. Auth creates new token                -- Can still use previously generated mobile token with the script
            DN Script  @ 60 sec : 987654   <-- script still maintains old

            Mobile App @ 75 sec : 135791
            DN Script  @ 75 sec : 135791   <-- script creates new token which matches

            . . .

        *After successfully authenticating to the script, a loop will continuously
        show this phase difference.

        I even tried setting my local Linux server at home to use Google NTP time
        servers, like the mobile app does, to see if this would help.
        It did not...


Implementation Description:

        TOTP:

            Time-based One Time Passwords, or TOTPs, are similar to HMAC-based
            One Time Passwords, except that the are only valid for a certain
            amount of time, usually 30 to 60 seconds.  In HOTP, one uses a key
            and a counter for each code generation.  Instead, TOTP uses a system
            timestamp for the counter.  Thus, each generation of the TOTP is
            unique.  This method is only valid if the two systems
            produce the exact same time stamps, else they will hash different
            values for the HMACs, and thus produce different codes.

            HOTP function:

                "Basically, the output of the HMAC-SHA-1 calculation is truncated to
                obtain user-friendly values:

                  HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))

                where Truncate represents the function that can convert an HMAC-SHA-1
                value into an HOTP value.  K and C represent the shared secret and
                counter value; see [RFC4226] for detailed definitions." [1]



        Python Code:

            Since the TOTP functions literally just call the get_hotp function
            with the key and a interval value, that being current system time,
            there is not much to explain here.

            HOTP Code:

              1. Turn the key into, using base64, a value HMAC can use.
              2. Fill a buffer message with an offset.
              3. Create a HMAC with the secret and the interval(in this case
              the timestamp)
              4. And the value with 15.
              5. Remove significant bits with & 0x7fffffff to remove the most
              significant bit, to remove any sign on the value.
              6. The output is then moddulo'ed with 1000000, to create a short,
              easy to use code.


References:

  [1] M'Raihi, D., Machani, S., Pei, M. and Rydell, J. (2017). RFC 6238 -
     TOTP: Time-based One-time Password Algorithm. [online] Tools.ietf.org.
     Available at: https://tools.ietf.org/html/rfc6238 [Accessed 3 Dec. 2017].
